<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audit Agentic AI Chatbot</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone@7.22.5/babel.min.js"></script>
    <!-- Markdown renderer and sanitizer for professional formatting -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.7/dist/purify.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root" class="min-h-screen bg-gray-100 flex flex-col items-center justify-center p-4"></div>
    <script type="text/babel">
        function Chatbot() {
            const [messages, setMessages] = React.useState([]);
            const [archives, setArchives] = React.useState([]); // list of previous chats
            const [input, setInput] = React.useState('');
            const [isLoading, setIsLoading] = React.useState(false);
            const [sessionId, setSessionId] = React.useState(null);
            const MAX_MESSAGES = 50; // sliding window size
            const endRef = React.useRef(null);
            const messagesRef = React.useRef(null);

            const scrollToBottom = () => {
                if (endRef.current) {
                    endRef.current.scrollIntoView({ behavior: 'smooth' });
                }
            };

            // Build Q/A pairs for sidebar history
            const pairs = React.useMemo(() => {
                const res = [];
                let pending = null;
                for (const m of messages) {
                    if (m.sender === 'user' || m.sender === 'human') {
                        // start a new pending question
                        pending = { q: m.text, a: null, sources: null };
                    } else if (m.sender === 'bot') {
                        if (pending && !pending.a) {
                            pending.a = m.text;
                            pending.sources = m.sources || null;
                            res.push(pending);
                            pending = null;
                        } else {
                            // bot message without a preceding user question
                            res.push({ q: null, a: m.text, sources: m.sources || null });
                        }
                    }
                }
                if (pending) {
                    // keep the last unanswered question visible
                    res.push(pending);
                }
                return res.slice(-MAX_MESSAGES);
            }, [messages]);

            // On mount: restore sessionId from localStorage
            React.useEffect(() => {
                const stored = window.localStorage.getItem('rag_session_id');
                if (stored && !sessionId) {
                    setSessionId(stored);
                }
            }, []);

            // Load conversation history when sessionId becomes available
            React.useEffect(() => {
                const loadHistory = async () => {
                    try {
                        const response = await fetch('/api/history', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ user_id: 'default_user', session_id: sessionId || '' })
                        });
                        if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
                        const data = await response.json();
                        if (data.history) {
                            const mapped = data.history.map(msg => ({
                                sender: msg.role,
                                text: msg.content,
                                sources: msg.role === 'assistant' ? 'From history' : null
                            }));
                            setMessages(() => mapped.slice(-MAX_MESSAGES));
                        }
                    } catch (error) {
                        console.error('Error loading history:', error);
                    }
                };
                if (sessionId) loadHistory();
            }, [sessionId]);

            // Auto-scroll whenever messages change
            React.useEffect(() => {
                scrollToBottom();
            }, [messages]);

            // Enhance code blocks with copy buttons (like ChatGPT)
            React.useEffect(() => {
                const container = messagesRef.current;
                if (!container) return;
                const pres = container.querySelectorAll('pre');
                pres.forEach(pre => {
                    if (pre.querySelector('.copy-btn')) return;
                    const btn = document.createElement('button');
                    btn.className = 'copy-btn absolute right-2 top-2 text-xs px-2 py-1 rounded bg-gray-800 text-white hover:bg-gray-700';
                    btn.textContent = 'Copy';
                    btn.addEventListener('click', () => {
                        const code = pre.innerText || '';
                        navigator.clipboard.writeText(code);
                        btn.textContent = 'Copied!';
                        setTimeout(() => (btn.textContent = 'Copy'), 1200);
                    });
                    pre.style.position = 'relative';
                    pre.appendChild(btn);
                });
            }, [messages]);

            // Start a new chat session: clear messages and session
            const newChat = () => {
                try {
                    window.localStorage.removeItem('rag_session_id');
                } catch (e) { /* ignore */ }
                // archive current messages (if any) at the top, and cap number of archived sessions
                setArchives(prev => (messages && messages.length > 0) ? [messages, ...prev].slice(0, 10) : prev);
                setMessages([]);
                setSessionId(null);
                setInput('');
            };

            const sendMessage = async () => {
                if (!input.trim()) return;
                setIsLoading(true);
                const userMessage = { sender: 'user', text: input };
                setMessages(prev => {
                    const updated = [...prev, userMessage];
                    return updated.slice(-MAX_MESSAGES);
                });

                try {
                    const response = await fetch('/api/query', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            question: input,
                            user_id: 'default_user',
                            session_id: sessionId,
                            n_results: 3
                        })
                    });
                    if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
                    const data = await response.json();
                    const sources = data.metadata ? data.metadata.join(', ') : 'No specific sources';
                    const botMessage = { 
                        sender: 'bot', 
                        text: data.answer || 'No response received',
                        sources
                    };
                    setMessages(prev => {
                        const updated = [...prev, botMessage];
                        return updated.slice(-MAX_MESSAGES);
                    });
                    if (data.session_id && !sessionId) {
                        setSessionId(data.session_id);
                        window.localStorage.setItem('rag_session_id', data.session_id);
                    }
                } catch (error) {
                    console.error('Error:', error);
                    const errorMessage = { sender: 'bot', text: 'Sorry, something went wrong.' };
                    setMessages(prev => {
                        const updated = [...prev, errorMessage];
                        return updated.slice(-MAX_MESSAGES);
                    });
                }

                setInput('');
                setIsLoading(false);
            };

            const handleKeyPress = (e) => {
                if (e.key === 'Enter' && !isLoading) {
                    sendMessage();
                }
            };

            return (
                <div className="w-full max-w-5xl mx-auto grid grid-cols-1 md:grid-cols-3 gap-4">
                    {/* Sidebar: Previous Q/A pairs */}
                    <aside className="md:col-span-1 bg-white rounded-lg shadow p-4 h-[32rem] overflow-y-auto border">
                        <h2 className="text-lg font-semibold mb-3">History</h2>
                        {pairs.length === 0 && archives.length === 0 && (
                            <div className="text-sm text-gray-500">No history yet</div>
                        )}
                        {/* Recent Q/A pairs from current chat */}
                        {pairs.length > 0 && (
                            <>
                                <h3 className="text-xs uppercase tracking-wide text-gray-500 mb-1">Current Chat</h3>
                                <ul className="space-y-2 mb-4">
                                    {pairs.map((p, idx) => (
                                        <li key={idx} className="p-2 rounded border hover:bg-gray-50 cursor-pointer" onClick={() => { if (p.q) setInput(p.q); }}>
                                            {p.q && (
                                                <div className="text-sm">
                                                    <span className="font-medium text-gray-800">Q:</span>
                                                    <span className="text-gray-700"> {p.q.length > 80 ? p.q.slice(0,80)+"…" : p.q}</span>
                                                </div>
                                            )}
                                            {p.a && (
                                                <div className="text-xs mt-1 text-gray-600">
                                                    <span className="font-medium">A:</span>
                                                    <span> {p.a.length > 100 ? p.a.slice(0,100)+"…" : p.a}</span>
                                                </div>
                                            )}
                                        </li>
                                    ))}
                                </ul>
                            </>
                        )}

                        {/* Archived previous chats */}
                        {archives.length > 0 && (
                            <div className="mt-2">
                                <h3 className="text-xs uppercase tracking-wide text-gray-500 mb-1">Previous Chats</h3>
                                <div className="space-y-2">
                                    {archives.map((chat, ci) => (
                                        <details key={ci} className="border rounded bg-gray-50">
                                            <summary className="cursor-pointer select-none px-3 py-2 text-sm font-medium text-gray-700">
                                                Chat #{ci + 1}
                                            </summary>
                                            <div className="p-3 space-y-2">
                                                {chat.map((msg, mi) => {
                                                    const isUser = msg.sender === 'user' || msg.sender === 'human';
                                                    let botHtml = null;
                                                    if (!isUser) {
                                                        try {
                                                            const raw = window.marked ? window.marked.parse(msg.text || '') : (msg.text || '');
                                                            botHtml = window.DOMPurify ? window.DOMPurify.sanitize(raw) : raw;
                                                        } catch (e) {
                                                            botHtml = msg.text || '';
                                                        }
                                                    }
                                                    return (
                                                        <div key={mi} className={`mb-2 ${isUser ? 'text-right' : 'text-left'}`}>
                                                            {isUser ? (
                                                                <div className="inline-block max-w-full bg-blue-500 text-white px-3 py-2 rounded-lg whitespace-pre-wrap">
                                                                    {msg.text}
                                                                </div>
                                                            ) : (
                                                                <div className="inline-block max-w-full bg-white text-gray-800 px-3 py-2 rounded-lg border">
                                                                    <div className="prose prose-sm max-w-none whitespace-pre-wrap" dangerouslySetInnerHTML={{ __html: botHtml }} />
                                                                    {msg.sources && (
                                                                        <div className="text-xs text-gray-500 mt-1">Sources: {msg.sources}</div>
                                                                    )}
                                                                </div>
                                                            )}
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                        </details>
                                    ))}
                                </div>
                            </div>
                        )}
                    </aside>

                    {/* Main chat pane */}
                    <div className="md:col-span-2 bg-white rounded-lg shadow-lg p-6">
                        <div className="flex items-center justify-between mb-4">
                            <h1 className="text-2xl font-bold">Audit Agentic AI Chatbot</h1>
                            <button
                                onClick={newChat}
                                className="text-sm px-3 py-1.5 border rounded hover:bg-gray-50"
                                title="Start a new conversation"
                            >
                                New Chat
                            </button>
                        </div>
                        <div ref={messagesRef} className="h-96 overflow-y-auto mb-4 p-4 border rounded-lg bg-gray-50">
                            {messages.map((msg, index) => {
                                const isUser = msg.sender === 'user' || msg.sender === 'human';
                                // For bot: render Markdown + sanitize. For user: plain text with preserved line breaks.
                                let botHtml = null;
                                if (!isUser) {
                                    try {
                                        const raw = window.marked ? window.marked.parse(msg.text || '') : (msg.text || '');
                                        botHtml = window.DOMPurify ? window.DOMPurify.sanitize(raw) : raw;
                                    } catch (e) {
                                        botHtml = msg.text || '';
                                    }
                                }
                                return (
                                    <div key={index} className={`mb-4 flex ${isUser ? 'justify-end' : 'justify-start'}`}>
                                        {!isUser && (
                                            <div className="mr-2 flex-shrink-0 w-8 h-8 rounded-full bg-green-600 text-white flex items-center justify-center text-sm font-semibold">AI</div>
                                        )}
                                        {isUser ? (
                                            <div className="max-w-full md:max-w-[80%]">
                                                <div className="bg-blue-600 text-white px-4 py-2 rounded-2xl rounded-br-sm whitespace-pre-wrap leading-relaxed shadow">
                                                    {msg.text}
                                                </div>
                                            </div>
                                        ) : (
                                            <div className="max-w-full md:max-w-[80%]">
                                                <div className="bg-white text-gray-800 px-4 py-3 rounded-2xl rounded-bl-sm border leading-relaxed shadow">
                                                    <div className="prose prose-sm max-w-none whitespace-pre-wrap" dangerouslySetInnerHTML={{ __html: botHtml }} />
                                                    {msg.sources && (
                                                        <div className="text-xs text-gray-500 mt-2">Sources: {msg.sources}</div>
                                                    )}
                                                </div>
                                            </div>
                                        )}
                                        {isUser && (
                                            <div className="ml-2 flex-shrink-0 w-8 h-8 rounded-full bg-blue-600 text-white flex items-center justify-center text-sm font-semibold">U</div>
                                        )}
                                    </div>
                                );
                            })}
                            <div ref={endRef} />
                        </div>
                        {isLoading && <div className="text-center text-gray-500">Generating response…</div>}
                        <div className="flex items-end gap-2">
                            <textarea
                                value={input}
                                onChange={(e) => setInput(e.target.value)}
                                onInput={(e) => { e.target.style.height = 'auto'; e.target.style.height = Math.min(e.target.scrollHeight, 200) + 'px'; }}
                                onKeyDown={(e) => { if (e.key === 'Enter' && !e.shiftKey && !isLoading) { e.preventDefault(); sendMessage(); } }}
                                rows={2}
                                className="flex-1 p-3 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white resize-none"
                                placeholder="Send a message. Press Enter to send, Shift+Enter for a new line."
                                disabled={isLoading}
                            />
                            <button
                                onClick={sendMessage}
                                className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-blue-300"
                                disabled={isLoading || !input.trim()}
                            >
                                Send
                            </button>
                        </div>

                        
                    </div>
                </div>
            );
        }

        try {
            ReactDOM.render(<Chatbot />, document.getElementById('root'));
        } catch (e) {
            console.error('React rendering error:', e);
            document.getElementById('root').innerHTML = '<p>Error loading chatbot. Check console for details.</p>';
        }
    </script>
</body>
</html>
